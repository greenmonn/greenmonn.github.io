---
title: "최적화 기법과 삶 속의 선택에 대한 단상"
tags: [essay]
---

Analogy between Metaheuristic Search Techniques and Life

<!--more-->

시험 공부를 하다가 쓸데없는 생각이 들었다. 이 수업에서 소개한 알고리즘을 가지고 내 삶을 결정하는 모든 행동과 선택을 설명해 볼 수 있지 않을까? 또는, 적어도 그런 시도는 해볼 수 있지 않을까.

아, 그전에 공부하고 있던 과목이 무엇인지에 대해서 설명하는 데에도 지면을 많이 할애해야 한다. 사실 시험 기간의 절반은 이것에 대해 고민하며 보냈다. 나는 대체 무엇을 배우고 있었던가?

마지막 학기에 내가 듣고 있는 유일한 전공 과목. 이 수업은 다양한 메타휴리스틱 기법을 소개하고, 이를 소프트웨어 엔지니어링 문제에 적용한 사례를 다룬다. 소프트웨어 엔지니어링의 범위를 프로그램 개발의 전체 생애 주기(Lifecycle)로 생각한다면, 요구사항 수집, 설계, 테스팅, 배포, 유지 보수 등에 이르는 과정 속에 발생하는 문제들에서 '메타휴리스틱' 알고리즘으로 최적해를 찾아내는 것이라고 말할 수 있겠다. 여전히 알쏭달쏭하기는 하지만.

## 메타휴리스틱 알고리즘

![메타몽](https://www.dropbox.com/s/2nr1ommn5m1sjqi/%EB%A9%94%ED%83%80%EB%AA%BD_%EA%B3%B5%EC%8B%9D_%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8.png?raw=1){: width="40%" height="40%"}
_메타몽은 아는데.. 메타휴리스틱은 잘..._

### 알고리즘

알고리즘, 이라는 단어에서 연상되는 것은 **잘 정의된 문제**와 이 **문제에서 요구하는 조건에 맞는 정답**을 정해진 동작을 통해 찾아나가는 과정이다.

> 알고리즘(라틴어, 독일어: Algorithmus, 영어: algorithm 알고리듬, IPA: [ǽlɡərìðm])은 수학과 컴퓨터 과학, 언어학 또는 관련 분야에서 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 것을 말한다.

프로그래머스나 LeetCode와 같은 사이트에서 알고리즘 문제를 풀어 본 적이 있다면, 어떤 값을 최소화/최대화하거나 _(ex. 거리가 최소인 경로 찾기)_ 특정 형태를 만족하도록 (_ex. 특정 규칙에 따라 encoding된 문자열)_ 하는 '정답'을 output으로 출력하게 하는 프로그램을 상상할 수 있을 것이다. 얼마 전 있었던 [카카오 코딩 테스트 문제](https://tech.kakao.com/2019/10/02/kakao-blind-recruitment-2020-round1/)를 예시로, 알고리즘 문제를 푸는 방법에 대해서 생각해 보자. 2번이나 5번 문제에서는 주어진 input을 가공하면 곧바로 조건에 맞는 output을 얻어낼 수도 있지만, 생각해보면 이렇게 시뮬레이션으로 깔끔하게 풀리는 경우는 잘 없다.

주어진 input과 제약 조건을 가지고 후보가 될 수 있는 답을 먼저 골라낸 후에, 정렬 등을 이용해서 목표가 되는 값이 최소가 되는 경우를 뽑아낸다. 또는 그렇게 최소가 되는 경로를 그래프나 트리 등 자료구조의 특성을 이용해서 바로 탐색하는 경우도 생각해 볼 수 있다. 예를 들어 문제 4번 같은 경우에는 trie 자료 구조를 사용하면 key에 해당하는 문자를 불필요한 탐색 없이 바로 찾아갈 수 있다.

데이터 구조를 사용해서든, 동적 계획법(Dynamic Programming)과 같은 기법을 사용해서든 우리는 연산량을 줄여서 최대한의 효율을 내는 알고리즘을 짜기 위해 자신의 머리를 쥐어짜곤 한다. 물론 효율성을 높인다고 해도 정확한 답을 도출해야 하는 것은 변함없다.

하지만 이렇게 우리의 프로그래밍 능력을 검증하기 위해 '정제된' 문제가 아닌, 현실의 문제를 생각해본다면 조금 다른 형태의 '알고리즘'을 받아들일 수도 있게 된다.

- 최적해와 최적해의 근삿값이 큰 차이가 없을 수도 있다
- 결국은 NP-hard, NP-complete 문제로 귀결되는 경우가 있다 (N이 조금만 커져도 살아있는 동안 절대 안 풀린다)

바로 **휴리스틱 알고리즘**이다.

### 휴리스틱, 그리고 휴리스틱 알고리즘

요즘은 운영체제에 꽤 신뢰도 높은 Defender가 내장되어 있어서 그런지, 바이러스 백신에 대한 관심이 줄어든 것 같다. 하지만 2010년도 근처만 하더라도 각종 바이러스 백신 엔진에 대한 벤치마킹, 비교글이 많이 돌아다녔던 기억이 난다. 몇몇 해외 제품들에서 '휴리스틱 엔진'을 탑재해서 높은 바이러스 탐지율을 자랑했었고, 그런 백신들이 벤치마크 결과에서 높은 점수를 얻으면서 사람들 사이에서 인기가 많았더랬다. (~~내 동년배들 다 소싯적에 백신 좀 써 봤다~~)

아무튼, 이 휴리스틱 엔진의 치명적인 단점이 있었으니, 정상 파일마저 감염 파일로 종종 진단한다는 것이었다. 벤치마크 기록만 믿고 다운받았다가 무고한 파일을 감옥에 집어넣는 일이 많았던 기억이 난다. 원칙적으로 이미 알려진 바이러스 파일의 패턴을 바탕으로 검사를 하게 되는데, 휴리스틱 기술을 사용하면 아직 알려지지 않은 위협 요소로부터 '정상적이지 않은 패턴'을 감지해서 바이러스로 진단하게 된다.

휴리스틱은 '발견법'이라고도 불리며, 근본적으로는 심리학에서 나온 용어다. 심리학자들은 인간의 불완전하지만 빠르고 효과적인 직관, 또는 **어림짐작**을 휴리스틱이라고 일컫는다. 그리고 이러한 사고방식을 컴퓨터의 연산 과정에 적용한 것이 휴리스틱 알고리즘이다.

불충분한 시간이나 정보로 인하여 체계적이고 합리적인 판단이 힘들 때 휴리스틱은 합리적인 시간으로 문제의 최적해를 근사할 수 있다. 즉, 위의 바이러스 백신 예시에서처럼 '바이러스 패턴'에 대한 불충분한 정보를 가지고도 완벽하진 않지만 유의미한 탐지 결과를 낼 수 있다.

**휴리스틱 알고리즘은 인간의 직관적 사고방식을 모방한다.** 불완전한 인간의 사고방식을 모방하기 때문에 해답의 엄밀함은 보장할 수 없다. 하지만 컴퓨터의 이점은 인간에 비해 훨씬 더 많은 시도(Trial & Error)를 할 수 있다는 것이다. 또 저장 공간이 모자라지 않은 한 한번 기억한 것은 절대 잊어버리지 않는다. 그러니 그들이 대신 수많은 시행착오를 거치도록 한다면 인간의 직관이 가진 장점은 십분 활용하면서 더 정확하고 의미있는 결과를 도출할 수 있는 것이다.

다양한 분야에서 휴리스틱 방법으로 문제를 푸는 시도가 가능하다. 하지만 특정한 문제를 목표로 휴리스틱 알고리즘을 하나하나 고안하기보다는 좀더 보편적인 상위 수준의 알고리즘을 먼저 고안하고, 이를 문제의 특성에 맞춰 적응시키는 것이 더 효과적일 수 있다.

이러한 상위 수준의 발견적 기법이 **메타휴리스틱**이고, 대부분 자연 법칙으로부터 영감을 받아 형성되었다.

대표적으로,

- 유전 알고리즘 (생물의 진화 과정과 유전 법칙 모방)
- 담금질 기법 (금속의 표면처리 과정에서 냉각 과정)
- 타부 서치 (인간이 기억을 하는 과정)

등이 있다.

### Search in Solution Space

공부를 하면서 잘 연결되지 않았던 것은 메타휴리스틱 알고리즘이 다양한 탐색(Search) 메소드로 귀결된다는 점이었다.

앞에서 제시한 유전 알고리즘 등의 기법들은 가능한 해(Solution)로 이루어진 공간(Solution Space)에서 좀더 좋은 해를 찾아가는(Search) 방법이라는 공통점을 가지고 있다. 인공면역체계(AIS)과 같이 학습을 기반으로 모델을 훈련하는 방식도 존재하지만, 기본적으로 초기해로부터 계속해서 더 나은 해를 탐색하는 과정이라는 것은 동일하다. 그런데 왜 휴리스틱 알고리즘은 Search Technique의 형태로 발전해왔을까? 사실 생각해보면 휴리스틱 자체가 직관적으로 빨리 찾아낼 수 있는 솔루션으로부터 시작해서 점점 더 개선된 답으로 나아가는 과정이기 때문에 해공간을 탐색한다고 보는 것이 자연스러운 접근 방법으로 여겨지기는 한다.
